// Generated by CoffeeScript 1.7.1
(function() {
  var MongoClient, fs, mycard, restify, server, settings;

  settings = require('./config.json');

  mycard = require('mycard-sdk');

  restify = require('restify');

  fs = require('fs');

  MongoClient = require('mongodb').MongoClient;

  server = restify.createServer({
    name: 'mycard-apis'
  });

  server.use(restify.acceptParser(server.acceptable));

  server.use(restify.authorizationParser());

  server.use(restify.dateParser());

  server.use(restify.queryParser());

  server.use(restify.jsonp());

  server.use(restify.gzipResponse());

  server.use(restify.bodyParser());

  server.use(restify.conditionalRequest());

  MongoClient.connect(settings['db_server'], settings['db_options'], function(err, db) {
    var decks, limited;
    console.log('nyanpass');
    decks = {
      list: function(req, res, next) {
        if (!req.legacy_decksync_compatible && req.username !== req.params.user) {
          res.header('WWW-Authenticate', 'Basic realm="MyCard API"');
          res.send(401);
          return next(false);
        }
        return db.collection('users').findOne({
          name: req.params.user
        }, function(err, user) {
          if (err) {
            return next(err);
          }
          if (user == null) {
            return next(new restify.ResourceNotFoundError());
          }
          return db.collection('decks_new').find({
            user: user['_id'],
            deleted: {
              $ne: true
            }
          }).toArray(function(err, decks) {
            var deck, _i, _len;
            if (err) {
              return next(err);
            }
            for (_i = 0, _len = decks.length; _i < _len; _i++) {
              deck = decks[_i];
              deck['user'] = user;
              if (req.legacy_decksync_compatible) {
                deck['cards'] = deck['card_usages'];
                delete deck['card_usages'];
              }
            }
            res.send(decks);
            return next();
          });
        });
      },
      show: function(req, res, next) {
        if (!req.legacy_decksync_compatible && req.username !== req.params.user) {
          res.header('WWW-Authenticate', 'Basic realm="MyCard API"');
          res.send(401);
          return next(false);
        }
        db.collection('users').findOne({
          name: req.params.user
        }, function(err, user) {
          if (err) {
            return next(err);
          }
          if (user == null) {
            return next(new restify.ResourceNotFoundError());
          }
          return db.collection('decks_new').find({
            user: user['_id'],
            name: req.params.name
          }, function(err, deck) {
            if (err) {
              return next(err);
            }
            if (deck == null) {
              return next(new restify.ResourceNotFoundError());
            }
            if (deck['deleted']) {
              res.send(410);
              return next(false);
            }
          });
        });
        return next();
      },
      update: function(req, res, next) {
        if (!req.legacy_decksync_compatible && req.username !== req.params.user) {
          res.header('WWW-Authenticate', 'Basic realm="MyCard API"');
          res.send(401);
          return next(false);
        }
        if (!req.query['cards']) {
          return next(new restify.MissingParameterError());
        }
        return db.collection('users').findOne({
          name: req.params.user
        }, function(err, user) {
          if (err) {
            return next(err);
          }
          if (user == null) {
            return next(new restify.ResourceNotFoundError());
          }
          return db.collection('decks_new').findOne({
            user: user['_id'],
            name: req.params.name
          }, function(err, deck) {
            var card_usages, now, updated_at;
            if (err) {
              return next(err);
            }
            if (req.query['updated_at']) {
              updated_at = new Date(req.query['updated_at']);
              now = new Date();
              if (updated_at > now) {
                updated_at = now;
              }
            } else {
              updated_at = new Date();
            }
            card_usages = mycard.card_usages_decode(req.query['cards']);
            if (deck != null) {
              if (deck['deleted'] || deck['updated_at'] <= updated_at) {
                if (mycard.card_usages_equal(deck['card_usages'], card_usages)) {
                  return db.collection('decks_new').update({
                    _id: deck['_id']
                  }, {
                    $set: {
                      updated_at: updated_at
                    },
                    $unset: {
                      deleted: ''
                    }
                  }, function(err) {
                    if (err) {
                      return next(err);
                    }
                    res.send(204);
                    return next();
                  });
                } else {
                  return db.collection('deck_versions').insert({
                    deck: deck['_id'],
                    card_usages: card_usages,
                    version: deck['version'] + 1,
                    created_at: updated_at
                  }, function(err, docs) {
                    if (err) {
                      return next(err);
                    }
                    return db.collection('decks_new').update({
                      _id: deck['_id']
                    }, {
                      $set: {
                        updated_at: updated_at,
                        card_usages: card_usages,
                        version: deck['version'] + 1
                      },
                      $unset: {
                        deleted: ''
                      }
                    }, function(err) {
                      if (err) {
                        return next(err);
                      }
                      res.setHeader('Location', "https://my-card.in/decks/" + req.params.user + "/" + req.params.name + ".json");
                      res.send(201);
                      return next();
                    });
                  });
                }
              } else {
                return next(new restify.ConflictError());
              }
            } else {
              return db.collection('decks_new').insert({
                name: req.params.name,
                user: user['_id'],
                created_at: updated_at,
                updated_at: updated_at,
                card_usages: card_usages,
                version: 1
              }, function(err, deck) {
                if (err) {
                  return next(err);
                }
                return db.collection('deck_versions').insert({
                  deck: deck['_id'],
                  card_usages: card_usages,
                  version: 1,
                  created_at: updated_at
                }, function(err) {
                  if (err) {
                    return next(err);
                  }
                  res.setHeader('Location', "https://my-card.in/decks/" + req.params.user + "/" + req.params.name + ".json");
                  res.send(201);
                  return next();
                });
              });
            }
          });
        });
      },
      "delete": function(req, res, next) {
        if (!req.legacy_decksync_compatible && req.username !== req.params.user) {
          res.header('WWW-Authenticate', 'Basic realm="MyCard API"');
          res.send(401);
          return next(false);
        }
        return db.collection('users').findOne({
          name: req.params.user
        }, function(err, user) {
          if (err) {
            return next(err);
          }
          if (user == null) {
            return next(new restify.ResourceNotFoundError());
          }
          return db.collection('decks_new').findOne({
            user: user['_id'],
            name: req.params.name
          }, function(err, deck) {
            if (err) {
              return next(err);
            }
            if (deck == null) {
              return next(new restify.ResourceNotFoundError());
            }
            if (deck['deleted']) {
              res.send(410);
              return next();
            } else {
              return db.collection('decks_new').update({
                _id: deck['_id']
              }, {
                $set: {
                  updated_at: new Date(),
                  deleted: true
                }
              }, function(err) {
                if (err) {
                  return next(err);
                }
                res.send(204);
                return next();
              });
            }
          });
        });
      },
      legacy_decksync_compatible: function(req, res, next) {
        var index;
        req.legacy_decksync_compatible = true;
        index = req.params.user.indexOf('@');
        if (index !== -1) {
          return req.params.user = req.params.user.slice(0, index);
        }
      }
    };
    limited = {
      list: function(req, res, next) {
        return fs.readFile('lflist.conf', {
          encoding: 'utf8'
        }, function(err, data) {
          var card_id, count, last, line, result, _i, _len, _ref, _ref1;
          if (err) {
            return next(err);
          }
          result = [];
          last = null;
          _ref = data.split("\n");
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            line = _ref[_i];
            switch (line[0]) {
              case '#':
              case void 0:
              case null:
                null;
                break;
              case '!':
                if (last) {
                  result.push(last);
                }
                last = {
                  id: line.slice(1),
                  cards: []
                };
                break;
              default:
                _ref1 = line.split(" "), card_id = _ref1[0], count = _ref1[1];
                last.cards.push({
                  card_id: card_id,
                  count: count
                });
            }
          }
          if (last) {
            result.push(last);
          }
          res.send(result);
          return next();
        });
      },
      list_conf: function(req, res, next) {
        return fs.readFile('lflist.conf', {
          encoding: 'utf8'
        }, function(err, data) {
          if (err) {
            return next(err);
          }
          res.setHeader('content-type', 'text/plain');
          res.send(data);
          return next();
        });
      }
    };
    server.get(/\/decks\//, function(req, res, next) {
      decks.legacy_decksync_compatible(req, res, next);
      return decks.list(req, res, next);
    });
    server.put(/\/decks\//, function(req, res, next) {
      decks.legacy_decksync_compatible(req, res, next);
      return decks.update(req, res, next);
    });
    server.del(/\/decks\//, function(req, res, next) {
      decks.legacy_decksync_compatible(req, res, next);
      return decks["delete"](req, res, next);
    });
    server.get('/decks/:user', decks.list);
    server.get('/decks/:user/:name', decks.show);
    server.put("/decks/:user/:name", decks.update);
    server.del("/decks/:user/:name", decks["delete"]);
    server.get('/limited', limited.list);
    server.get('/limited.json', limited.list);
    server.get('/limited.conf', limited.list_conf);
    return server.listen(9004);
  });

}).call(this);

//# sourceMappingURL=app.map
